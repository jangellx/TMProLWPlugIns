<html><head>
<!-- $Id: lwob.htmX 2.4 1997/11/06 23:20:33 shf Exp $ -->
<title>LightWave 3D Object File Format</title>
</head>

<body>
<center><h1>
			LightWave 3D Object File Format
</h1><h2>
				Oct 16, 1996
</center></h2>

<!------------------------------>
<h3><hr>
Contents
</h3>

<ul>
    <li><a href="#S1">Introduction</a>
    <li><a href="#S2">Types and Structures</a>
    <li><a href="#S3">Object File Chunks</a>
    <li><a href="#S4">Surface Sub-chunks</a>
    <ul>
	<li><a href="#S4.1">Basic Surface Parameters</a>
	<li><a href="#S4.2">Texture Definitions</a>
	<li><a href="#S4.3">Plug-in Shaders</a>
	<li><a href="#S4.4">Image Filenames and Options</a>
    </ul>
    <li><a href="#S5">Object File Example</a>
    <li><a href="#S6">Index</a>
</ul>

<!------------------------------>
<h2><hr> <a name="S1">
Introduction
</h2> </a>

LightWave 3D objects are stored on disk as 3D meshes consistsing of
points, polygons (which can be faces, curves or patches), and surfaces.
Files can contain a single connected mesh or several disjoint meshes
describing a single logical object.  An object file may also contain 
one or more surface definitions with no mesh.
<p>
This document describes the high-level format of the file, and describes
in detail all the elements of the file.  There is a sample file at the
end displayed as an annotated dump.
<p>


<!------------------------------>
<h2><hr> <a name="S2">
Types and Structures
</h2> </a>

LightWave 3D object files are binary files composed of a series of bytes
in the range of 0 to 255.  The format conforms to the IFF ("Interchange File Format")
specification with a FORM-type of <tt>LWOB</tt>.  The full IFF format specification
can be found in
"<a href="iff_doc.html">EA IFF 85 Standard for Interchange Format Files</a>,"
but a simplified description is included here.
<p>
The atomic (or lowest-level) types in the file are listed below along with 
their type name (<b>I2</b>, <b>F4</b>, etc.).  These are used interpret sequences
of bytes in the file.
<p>

<dl><dl>
<dt><i>		<a name="t_ID4">
    ID Tag
</i><tt><b><dd>
	ID4
<p></b></tt><dd>	</a>
	An ID tag is a sequence of 4 bytes interpreted as 7-bit ASCII values,
	usually upper-case.  These tags are used to identify the type of data
	which follows.  <tt>FORM</tt>, <tt>SURF</tt>, <tt>POLS</tt>, and 
	<tt>LWOB</tt> are all examples of ID tags.

<p><dt><i>	<a name="t_I">
    Signed Integer
</i><tt><b><dd>
	I1, I2, I4
</tt></b><dt><i>
    Unsigned Integer
</i><tt><b><dd>
	U1, U2, U4
<p></tt></b><dd>	</a>
	Integers can have 1, 2 or 4 bytes and can be signed or unsigned.
	The most significant byte comes first in the file, so bytes read 
	into memory should be reversed before being interpreted on Intel 
	and compatible CPUs.

<p><dt><i>	<a name="t_F4">
    Float
</i><tt><b><dd>
	F4
<p></b></tt><dd>	</a>
	Floats are written as 4 byte IEEE floating-point values.  The
	bytes should generally be reversed before being interpreted on 
	Intel and compatible CPUs.

<p><dt><i>	<a name="t_S0">
    String
</i><tt><b><dd>
	S0
<p></b></tt><dd>	</a>
	Names or other character strings are written as a series of 
	ASCII character values followed by a zero (or null) byte.  If the 
	length of the string plus the null terminating byte is odd, an 
	extra null is added to make the total length even.
</dl></dl>

		<a name="t_CHUNK">
The basic structural element in an IFF file is the <em>Chunk</em>.  This is
given by the structure:
<p>		</a>

<dl><dl><dd><tt><b>
	CHUNK ::= tag<a href="#t_ID4"><a href="#t_ID4">[ID4]</a></a>,
		length<a href="#t_I">[U4]</a>,
		data[...], pad<a href="#t_I">[U1]</a> ?
</dl></dl></tt></b>

Each chunk starts with an ID tag which indicates the type of chunk, and an
unsigned four-byte integer which indicates the length of the data.  After that
follows <i>length</i> bytes of data and an optional pad byte if <i>length</i> is odd.
The pad byte, if included, should have a value of zero.
<p>

		<a name="t_SUBCH">
LightWave objects also have the <em>Sub-chunk</em> (or mini-chunk) structural
element which
is just like a chunk except that the length is given by a two-byte unsigned
integer.  Sub-chunks are specific to LightWave objects, not general IFF files.
<p>		</a>

<dl><dl><dd><tt><b>
	SUB-CHUNK ::= tag<a href="#t_ID4">[ID4]</a>, 
		length<a href="#t_I">[U2]</a>, 
		data[...], pad<a href="#t_I">[U1]</a> ?
</dl></dl></tt></b>

		<a name="t_FORM">
For the purposes of this document, chunks and sub-chunks are written as
"<b><i>id-tag</i> { <i>data</i> }</b>".  The entire file can be an example of
this notation, since it is itself a <tt>FORM</tt> chunk containing the ID 
tag <tt>LWOB</tt> and a series of data chunks.
<p>		</a>

<dl><dl><dd><tt><b>
	FORM { 'LWOB'<a href="#t_ID4">[ID4]</a>, 
		data<a href="#t_CHUNK">[CHUNK]</a> * }
</dl></dl></tt></b>

Very roughly, object files 
start with the four bytes "<tt>FORM</tt>" followed by a four-byte integer giving
the length of the file (not including the first 8 bytes) and the four 
bytes of the FORM-type, "<tt>LWOB</tt>".  The remainder of the data is a series of
chunks, each given by a four-character type and a four-byte length for
the data which follows.  The contents of each chunk is determined by its
type.
<p>
The chunks can occur in any order except when the data in a chunk depends
on knowing the values in previous chunks, in which case the dependant
chunk must occur after the chunk it depends upon.  The Layout and Modeler
portions of LightWave 3D write their chunks in slightly different orders,
so it is important for parsers to support order-independence.
<p>

The LightWave format has some composite datatypes that it uses consistently 
which are built from the fundamental types.
<p>

<dl><dl>

<dt><i> <a name="t_COL4">
    Color
<dd></i><b><tt> </a>
	COL4 ::= red<a href="#t_I">[U1]</a>,
		 green<a href="#t_I">[U1]</a>,
		 blue<a href="#t_I">[U1]</a>,
		 pad<a href="#t_I">[U1]</a>
</b></tt><p><dd>
	A color is written as an RGB triple, with each color component
	being in the range of 0 to 255.  0,0,0 is full black and 255,255,255
	is full white and the total number of possible colors is 16,777,216.
	Colors are written with a pad byte to make the length
	even which is currently unused and should always be zero.

<p><dt><i> <a name="t_VEC12">
    Coordinate
<dd></i><b><tt> </a>
	VEC12 ::= X<a href="#t_F4">[F4]</a>,
		  Y<a href="#t_F4">[F4]</a>,
		  Z<a href="#t_F4">[F4]</a>
</b></tt><p><dd>
	3D coordinates are written as an XYZ vector in floating
	point format.  The values are distances along the X, Y, and Z axes.

<p><dt><i> <a name="t_IP2">
    Integer Percentage
<dd></i><b><tt> </a>
	IP2 ::= scaled-value<a href="#t_I">[I2]</a>
</b></tt><p><dd>
	Percentages can be written as a fixed-point integer value, where
	0 is equal to 0% and 256 is equal to 100%.

<p><dt><i> <a name="t_FP4">
    Floating Point Percentage
<dd></i><b><tt> </a>
	FP4 ::= fractional-value<a href="#t_F4">[F4]</a>
</b></tt><p><dd>
	Percentages can also be written as a floating point value, where
	0.0 is equal to 0% and 1.0 is equal to 100%.

<p><dt><i> <a name="t_DEG4">
    Angle
<dd></i><b><tt> </a>
	DEG4 ::= degrees<a href="#t_F4">[F4]</a>
</b></tt><p><dd>
	Angles are specified as floating point values expressed in degrees.

<p><dt><i> <a name="t_FNAM0">
    Filename
<dd></i><b><tt> </a>
	FNAM0 ::= name<a href="#t_S0">[S0]</a>
</b></tt><p><dd>
	Filenames (such as the names of images) are written as strings.  They
	are interpreted as filenames on the host system directly, except for
	the automatic conversion of forward-slashes into backslashes on DOS
	systems, and backslashes into forward-slashes on Unix systems.

</dl></dl>


<!------------------------------>
<h2><hr> <a name="S3">
Object File Chunks
</h2> </a>

The following section describes all the chunks that can be found in a LightWave
object file.  Their order here is not important, except that chunks which
define values in other chunks are listed first.
<p>

<dl><dl>
<dt><i> <a name="c_PNTS">
    Point List
</i><p><dd><tt><b> </a>
	PNTS { point-location<a href="#t_VEC12">[VEC12]</a> * }
</tt></b><p>
This chunk contains a list of the X, Y, and Z coordinates of all
the points in an object.  Since each coordinate has three components, and
each component is stored as a four byte
floating point number, the number of points in an object can be 
determined by dividing the size in bytes of the <tt>PNTS</tt> chunk by 12.
<p>
By convention, the +X direction is to the right or east, the +Y
direction is upward, and the +Z direction is forward or north.
For models of real-world objects, the unit size is usually
considered to be one meter.  The coordinates are specified relative
to an object's pivot point.  See the LightWave Modeler manual for
more information about LightWave 3D's geometric conventions.
<p>
Points in the <tt>PNTS</tt> chunk are numbered in the order they occur, starting
with zero.  This index is then used by polygons to define their
vertices.  The <tt>PNTS</tt> chunk must be before the 
<a href="#c_POLS"><tt>POLS</tt></a>,
<a href="#c_CRVS"><tt>CRVS</tt></a>, and
<a href="#c_PCHS"><tt>PCHS</tt></a>
chunks in the file.
<p>

<dt><i> <a name="c_SRFS">
    Surface List
</i><p><dd><tt><b> </a>
	SRFS { surf-name<a href="#t_S0">[S0]</a> * }
</tt></b><p>
This chunk contains a list of the names of all the surfaces in an
object.  Each surface name
appears as a null-terminated character string.  If the length of
the string (including the null) is odd, an extra null byte is
added.  Surface names should be read from the file until as many
bytes as the chunk size specifies have been read.
<p>
In LightWave 3D terminology, a "surface" is defined as a named set 
of shading attributes.  Each polygon contains a reference to the
surface used to color the polygon.  The names as listed in the <tt>SRFS</tt> 
chunk are numbered in the order they occur, starting from 1, and
this index is used by polygons to define their surface.  The <tt>SRFS</tt>
chunk must be before the
<a href="#c_POLS"><tt>POLS</tt></a>,
<a href="#c_CRVS"><tt>CRVS</tt></a>, and
<a href="#c_PCHS"><tt>PCHS</tt></a>
chunks in the file.
<p>

<dt><i> <a name="c_POLS">
    Face List
</i><p><dd><tt><b> </a>
	POLS { ( numvert<a href="#t_I">[U2]</a>, vert<a href="#t_I">[U2]</a> # numvert, surf<a href="#t_I">[I2]</a> )* }
</tt></b><p>
This chunk contains a list of all the polygons in an object.  Each
entry consists of a short integer specifying the number of vertices
in the polygon followed by that many short integers specifying the
vertices themselves (as indices into the points list) followed by a
short integer specifying which surface is used by the polygon (as
an index into the surfaces list).  The number of vertices in a
polygon currently may vary from one to 200.  The vertex list for
each polygon should begin at a convex vertex and proceed clockwise
as seen from the visible side of the polygon (LightWave 3D polygons
are single-sided, except for those whose surfaces have the double-sided 
flag set).  Polygons should be read from the file until as many
bytes as the chunk size specifies have been read.
<p>
<em>Since the points in the
<a href="#c_PNTS"><tt>PNTS</tt></a>
chunk are referenced using two-byte
integers, the effective maximum number of points in a LightWave object file
is 65,536.  This is an inherient limitation of this current format.</em>
<p>
A negative surface number for a polygon indicates that the polygon
has detail polygons (which are drawn on top of the main polygon and
may be coplanar with it).  In this case, the next number in the
file is a short integer specifying how many detail polygons belong
to the current polygon.  This is followed by a list of those detail
polygons, where each entry is of the same format as described above
for regular polygons (except that the detail polygons cannot have
details of their own).  The list of regular polygons then resumes.
To determine which surface is used by a polygon with a negative
surface number, the absolute value of that number should be used.
Note, however, that detail polygons are mostly obsolete, so even
though they may be recognized by LightWave and old files contain 
them, they should be ignored.
<p>

<dt><i> <a name="c_CRVS">
    Curve List
</i><p><dd><tt><b> </a>
	CRVS { ( numvert<a href="#t_I">[U2]</a>,
		 vert<a href="#t_I">[U2]</a> # numvert,
		 surf<a href="#t_I">[I2]</a>,
		 flags<a href="#t_I">[U2]</a> )* }
</tt></b><p>
This chunk contains a list of all the spline curves in an object. 
Each entry consists of a short integer specifying the number of
vertices in a curve followed by that many short integers specifying
the vertices themselves in sequential order, followed by a short
integer specifying which surface is used by the curve, followed by
another short integer specifying bit-flags associated with the
curve.  If bit zero is set then the first point is a continuity
control point, and if bit one is set then the last point is.  The
point and surface indices are as they are in the
<a href="#c_POLS"><tt>POLS</tt></a>
chunk, except
that curves cannot have details.  Curves should be read from the
file until as many bytes as the chunk size specifies have been read.
<p>

<dt><i> <a name="c_PCHS">
    Patch List
</i><p><dd><tt><b> </a>
	PCHS { ( numvert<a href="#t_I">[U2]</a>,
		 vert<a href="#t_I">[U2]</a> # numvert,
		 surf<a href="#t_I">[I2]</a> )* }
</tt></b><p>
This chunk contains a list of all the MetaNURBS(tm) patches in an object. 
The entries are the same as the
<a href="#c_POLS"><tt>POLS</tt></a>
chunk, except
that patches cannot have details. Patches should be read from the
file until as many bytes as the chunk size specifies have been read.
<p>
<em>MetaNURBS patches are currently limited to four vertices.  Other numbers
of vertices will load and save but will not display.  MetaNURBS patches are
also limited to Modeler only and do not display in Layout or render.</em>
<p>

<dt><i> <a name="c_SURF">
    Surface Definition
</i><p><dd><tt><b> </a>
	SURF {  name<a href="#t_S0">[S0]</a>,
		attributes<a href="#t_SUBCH">[SUB-CHUNK]</a> * }
</tt></b><p>
Each <tt>SURF</tt> chunk describes the surface attributes of a particular
surface.  These chunks begin with the name of the surface being
described.  Following the name is a series of sub-chunks, which are like normal
IFF chunks except that their sizes are specified by short integers
instead of longs.  It is likely that the variety of sub-chunks will
grow as new surface attributes are added to the program, but any
unknown sub-chunks may be skipped over by using the size.
Sub-chunks should be read from the file until as many bytes as the
chunk size specifies have been read.
<p>
</dl></dl>

<!------------------------------>
<h2><hr>	<a name="S4">
Surface Sub-chunks
</h2>	</a>

The <a href="#c_SURF"><tt>SURF</tt></a>
surface sub-chunks create a simple but varied language for
describing surface parameters of LightWave objects.  These chunks mostly
correspond to the settings in the program's interface, so a complete
understanding of the program is very useful for interpreting these chunks.
<p>

<h3>	<a name="S4.1">
Basic Surface Parameters
</h3>	</a>
The following surface sub-chunks define the base characteristics of a
surface.  These are values that are independent of texturing and correspond
roughly to the main Surface control panel in Layout.  Even if the effects of 
textures and shaders overrides these settings completely in final rendering,
as many of these should still be specified as possible since they are also
used for previewing and real-time rendering.
<p>

<dl><dl>
<dt><i>		<a name="s_COLR">
    Base Color
</i><p><dd><tt><b> </a>
	COLR { base-color<a href="#t_COL4">[COL4]</a> }
</tt></b><p>
	This defines the base color of the surface, which is the color that lies
	under all the other texturing attributes.
<p>

<dt><i>		<a name="s_FLAG">
    Surface State Flags
</i><p><dd><tt><b> </a>
	FLAG { flags<a href="#t_I">[U2]</a> }
</tt></b><p>
    Surface flags are stored in a short integer whose bits specify
    various options for the current surface.  Currently the
    twelve least significant bits are used.  The options that set bits
    indicate are (starting with the least significant bit):
    Luminous, Outline, Smoothing, Color Highlights, Color Filter,
    Opaque Edge, Transparent Edge, Sharp Terminator, Double Sided,
    Additive, and Shadow Alpha.
<p>
	The two edge transparency bits should not both be set.  The
	luminous bit has been superceded by the <tt>LUMI</tt> and <tt>VLUM</tt> chunks
	which specify an explicit luminosity percentage.  If no explicit
	luminosity is specified, the Luminous bit sets the luminosity
	to 100%.
<p>

<dt><i>		<a name="s_Vxxx">
    Base Shading Values
</i><p><dd><tt><b> </a>
	LUMI, DIFF, SPEC, REFL, TRAN { percentage<a href="#t_IP2">[IP2]</a> }<br>
	VLUM, VDIF, VSPC, VRFL, VTRN { percentage<a href="#t_FP4">[FP4]</a> }
</tt></b><p>
	These sub-chunks specify the base level of the surface's
	luminosity, diffuse, specular, reflection, or transparency settings.
	Each setting has a fixed-point and a floating-point form, but if
	both are present the floating-point form should take precedence.
	The fixed-point value should be rounded to the nearest half percent.
	Even though the floating-point form is prefered, the convention is
	to write both sub-chunks to a surface description to support older
	parsers.  If any of these sub-chunks are absent for a surface, a
	value of zero is assumed.  The <tt>LUMI</tt> or <tt>VLUM</tt> sub-chunk
	overrides the Luminous bit of the <tt>FLAG</tt> sub-chunk.
<p>
	<tt>REFL</tt> and <tt>SPEC</tt> sub-chunks may have an incorrect length of
	4 instead of 2.  Even though that bug has been fixed, there may still
	be object files around with this error.
<p>

<dt><i>		<a name="s_GLOS">
    Specular Glossiness
</i><p><dd><tt><b> </a>
	GLOS { glossiness<a href="#t_I">[I2]</a> }
</tt></b><p>
	Glossiness is stored as a short integer and is only needed if the
	specular setting in the <tt>SPEC</tt> or <tt>VSPC</tt> sub-chunk is non-zero.  A 
	value of 16 indicates low glossiness, 64 indicates medium 
	glossiness, 256 indicates high glossiness, and 1024 indicates 
	maximum glossiness.  This parameter is related to the "specular 
	exponent" used in many lighting models.
<p>
	<tt>GLOS</tt> sub-chunks may have have an incorrect length of
	4 instead of 2.  Even though that bug has been fixed, there may still
	be object files around with this error.
<p>

<dt><i>		<a name="s_RFLT">
    Reflection Mode
</i><p><dd><tt><b> </a>
	RFLT { reflection-mode<a href="#t_I">[U2]</a> }
</tt></b><p>
    The reflection mode is a numeric code that describes
    how reflections are handled for this surface and is only meaningful
	if the reflectivity of the surface is non-zero.  If the mode is 0, then
	only the backdrop colors in the scene are reflected.  If the mode is
	1, it is the same as 0 except that raytracing is used for objects in 
	the scene when it is enabled.  If the mode is 2 and an image is
	provided by the <tt>RIMG</tt> sub-chunk, then the image wrapped spherically
	around the scene is reflected.  If the mode is 3, it is the same
	as 2 except that raytracing is used when enabled.  If there is no
	<tt>RFLT</tt> sub-chunk, a value of 3 is assumed.
<p>

<dt><i>		<a name="s_RIMG">
    Reflection Map Image
</i><p><dd><tt><b> </a>
	RIMG { image-file<a href="#t_FNAM0">[FNAM0]</a> }
</tt></b><p>
	The reflection image is wrapped around the scene and is used for
	reflection mapping if the <tt>RFLT</tt> mode is set to use an image and the
	reflectivity of the surface is non-zero.  If the <tt>RFLT</tt> mode setting
	expects an image and there is no <tt>RIMG</tt> chunk, then the backdrop
	colors are reflected.
	See the section on <a href="#S4.4">Image Options</a> for more on
	specifying image names.<p>

<dt><i>		<a name="s_RSAN">
    Reflection Map Image Seam Angle
</i><p><dd><tt><b> </a>
	RSAN { seam-angle<a href="#t_DEG4">[DEG4]</a> }
</tt></b><p>
	This angle is the heading angle of the reflection map seam.  If missing,
	a value of zero is assumed.
<p>

<dt><i>		<a name="s_RIND">
    Refractive Index
</i><p><dd><tt><b> </a>
	RIND { refractive-index<a href="#t_F4">[F4]</a> }
</tt></b><p>
    The surface's refractive index is
    defined as the ratio of the speed of light in a vacuum to the
    speed of light in the material.  Since light is fastest in a
    vacuum, this value should therefore be greater than or equal to
    1.0.
<p>

<dt><i>		<a name="s_EDGE">
    Edge Transparency Threshold
</i><p><dd><tt><b> </a>
	EDGE { edge-trans<a href="#t_F4">[F4]</a> }
</tt></b><p>
    The edge transparency threshold of the current
    surface should lie between 0.0 and 1.0.
<p>

<dt><i>		<a name="s_SMAN">
    Max Smoothing Angle
</i><p><dd><tt><b> </a>
	SMAN { max-smoothing-angle<a href="#t_DEG4">[DEG4]</a> }
</tt></b><p>
    This specifies the maximum angle between two adjacent polygons
    that can be smooth shaded.  Polygons with
    a greater angle between them will appear to meet at a sharp seam.
<p>

<dt><i>		<a name="s_ALPH">
    Alpha Mode
</i><p><dd><tt><b> </a>
	ALPH { mode<a href="#t_U2">[U2]</a>, value<a href="#t_U2">[U2]</a> }
</tt></b><p>
    This chunk defines a more advanced set of alpha channel output options
    which supercede the Shadow Alpha bit in the <tt>FLAG</tt> chunk.  If mode
    is 0, this surface does not affect the Alpha channel at all when rendered.
    If mode is 1, the alpha channel will have a fixed value which is the
    second parameter in the chunk and should have a value from 0 to 255.  If
    mode is 2, the alpha value is derived from surface opacity.  If
    mode is 3, the alpha value comes from shadow density.  If the <tt>ALPH</tt>
    chunk is missing, then the alpha mode is 2 normally and 3 if the Shadow
    Alpha bit is set.
<p>
</dl></dl>


<h3>	<a name="S4.2">
Texture Definitions
</h3>	</a>
Surface textures in LightWave correspond closely to the Textures panel
accessed though the Surfaces panel.  They are algorithmic or image-based
modulations of one of the shading parameters.  Any number of textures may
be used and their effect is cumulative.
<p>

<dl><dl>
<dt><i>		<a name="s_xTEX">
    Start Texture Definition
</i><p><dd><tt><b> </a>
	CTEX, DTEX, STEX, RTEX, TTEX, LTEX, BTEX { texture-type<a href="#t_S0">[S0]</a> }
</tt></b><p>
    The presence of one of these sub-chunks indicates that the
    current surface has a color, diffuse, specular, reflection,
    transparency, luminosity, or bump texture.  The contents of the sub-chunk is
    a character string  specifying the texture type as shown on the 
    control panel.  Once one of these sub-chunks is encountered within 
    a <tt>SURF</tt> chunk, all subsequent texture-related sub-chunks 
    are considered to pertain to the current texture,
    until another one of these texture starting sub-chunks is 
    read.  There may be any number of textures for each parameter, and
    the textures are layered in the order they are read.
<p>

<dt><i>		<a name="s_TFLG">
    Texture Flags
</i><p><dd><tt><b> </a>
	TFLG { texture-flags<a href="#t_I">[U2]</a> }
</tt></b><p>
    This short integer has bits which specify
    various options for the current texture.  Currently only the
    seven least significant bits are used.  The options that set bits
    indicate are (starting with the least significant bit):  X Axis,
    Y Axis, Z Axis, World Coordinates, Negative Image, Pixel Blending, and
    Antialiasing.  Note that only one of the three axis bits should
    be set.
<p>

<dt><i>		<a name="s_TSIZ">
    Location and Size
</i><p><dd><tt><b> </a>
	TSIZ, TCTR, TFAL, TVEL { vector<a href="#t_VEC12">[VEC12]</a> }
</tt></b><p>
    These sub-chunks each consist of a vector for the
    current texture's size, center, falloff, or velocity.  If missing,
	the center, falloff and velocity are assumed to be zero.
	The size should always be specified for any texture.
<p>

<dt><i>		<a name="s_TREF">
    Texture Reference Object
</i><p><dd><tt><b> </a>
	TREF { object-name<a href="#t_S0">[S0]</a> }
</tt></b><p>
    This subchuck specifies a reference object for the texture.  The reference
    object is given by name, and the position, rotation and scale of the object
    are used to compute the texture coordinates time.  This chunk overrides the
    World Coordinates bit in the <tt>TFLG</tt> sub-chunk, and the location and
    size settings of the texture are applied in the coordinate frame of the
    reference object.
<p>

<dt><i>		<a name="s_TCLR">
    Texture Color
</i><p><dd><tt><b> </a>
	TCLR { texture-color<a href="#t_COL4">[COL4]</a> }
</tt></b><p>
    This specifies the modifying color used by a <tt>CTEX</tt> texture.
<p>

<dt><i>		<a name="s_TVAL">
    Texture Value
</i><p><dd><tt><b> </a>
	TVAL { texture-value<a href="#t_IP2">[IP2]</a> }
</tt></b><p>
    This specifies the modifying value of a <tt>DTEX</tt>, <tt>STEX</tt>,
	<tt>RTEX</tt>, <tt>TTEX</tt>, or <tt>LTEX</tt>
	texture as a fixed-point percentage.
<p>

<dt><i>		<a name="s_TAMP">
    Bump Texture Amplitude
</i><p><dd><tt><b> </a>
	TAMP { bump-amplitude<a href="#t_FP4">[FP4]</a> }
</tt></b><p>
    This specifies the amplitude of the current <tt>BTEX</tt> bump texture as
	a floating-point percentage.
<p>

<dt><i>		<a name="s_TxPn">
    Algorithmic Texture Parameters
</i><p><dd><tt><b> </a>
	TFP0, TFP1, TFP2, ... { float-parameter<a href="#t_F4">[F4]</a> }<br>
	TIP0, TIP1, TIP2, ... { integer-parameter<a href="#t_I">[I2]</a> }<br>
<br>
	TSP0, TSP1, TSP2 { float-parameter<a href="#t_F4">[F4]</a> }<br>
	TFRQ { noise-freq<a href="#t_I">[U2]</a> }
</tt></b><p>
    The <tt>TFPn</tt> sub-chunks each contain a floating point
    number that specifies one of the special texture type-specific
    parameters (such as Contrast, Turbulence, Wavelength, etc).
    The <tt>TIPn</tt> sub-chunks are similar but are used for integer
    parameters (such as number of Frequencies, Wave Sources, etc).
    Which sub-chunk is used to record a particular parameter depends
    on the order in which that parameter's button appears on the
    control panel.  The total number of possible sub-chunks may increase
	in the future, but the totals for 5.0 are 4 floating-point and
	1 integer.
<p>
	The <tt>TSPn</tt> sub-chunks are an obsolete form of the <tt>TFPn</tt>
	sub-chunks.  The <tt>TFRQ</tt> sub-chunk is an obsolete form of
	<tt>TIP0</tt> from a time when the number of fractal noise 
	frequencies or number of wave sources was the only integer algorithmic
	parameter.  LightWave will still parse these older sub-chunks but it no
	longer writes them.
<p>

<dt><i>		<a name="s_TIMG">
    Image Map
</i><p><dd><tt><b> </a>
	TIMG { texture-image<a href="#t_FNAM0">[FNAM0]</a> }
</tt></b><p>
    This specifies an image name to be used for image texture mapping.  
	See the section on <a href="#S4.4">Image Options</a> for more on
	specifying image names.
<p>

<dt><i>		<a name="s_TALP">
    Image Alpha
</i><p><dd><tt><b> </a>
	TALP { texture-alpha<a href="#t_FNAM0">[FNAM0]</a> }
</tt></b><p>
    This specifies an image name to be used as the alpha map for this texture.
	See the section on <a href="#S4.4">Image Options</a> for more on
	specifying image names.
<p>

<dt><i>		<a name="s_TWRP">
    Image Wrap Options
</i><p><dd><tt><b> </a>
	TWRP { width-wrap<a href="#t_I">[U2]</a>, height-wrap<a href="#t_I">[U2]</a> }
</tt></b><p>
    This specifies how image-based textures will interpret the color of areas
	outside the image.  If the mode is 0, then outside the image is considered to
	be black.  If the mode is 1, areas outside the image are clamped to the
	closest image edge value.  If the mode is 2, then the image repeats outside
	the image area resulting in a uniform tiling.  If the mode is 3, then the
	image repeats but with mirroring, so that each each adjacent repetition is
	reversed.  If no wrap options are specified, 2 is assumed.
<p>

<dt><i>		<a name="s_TAAS">
    Antialiasing Strength
</i><p><dd><tt><b> </a>
	TAAS { antialising-strength<a href="#t_FP4">[FP4]</a> }
</tt></b><p>
	This specifies the strength of antialiasing used for the texture.  If the
	Antialiasing bit is set in the <tt>TFLG</tt> sub-chunk and this sub-chunk
	is missing, 100% is assumed.  This setting currently only affects
	image-based textures.
<p>

<dt><i>		<a name="s_TOPC">
    Texture Opacity
</i><p><dd><tt><b> </a>
	TOPC { texture-opacity<a href="#t_FP4">[FP4]</a> }
</tt></b><p>
	This specifies how opaque this texture is with respect to the textures
	before it.  If no opacity is specified, 100% is assumed.
<p>
</dl></dl>


<h3>	<a name="S4.3">
Plug-in Shaders
</h3>	</a>
Plug-in shaders are applied to a surface after all built-in textures.
They are evaluated in the order specified in the surface description and
there can currently be up to four.
<p>

<dl><dl>
<dt><i>		<a name="s_SHDR">
    Shader Plug-in
</i><p><dd><tt><b> </a>
	SHDR { name<a href="#t_S0">[S0]</a> }
</tt></b><p>
	Plug-in shaders are identified by their server name, which is stored
	in this sub-chunk.
<p>

<dt><i>		<a name="s_SDAT">
    Shader Data
</i><p><dd><tt><b> </a>
	SDAT { shader-data[...] }
</tt></b><p>
	A shader can store up to 65,535 bytes of data to describe its settings,
	and these are stored directly in this sub-chunk without modification.
	The length and contents of this chunk will depend completely on the
	shader specified by the previous <tt>SHDR</tt> chunk.
<p>
	<em>Shaders should always write an even number of data bytes.  A bug 
	in some versions of 5.0 causes <tt>SDAT</tt> chunks with an odd number of data
	bytes to subtly currupt the object file.</em>
<p>
</dl></dl>


<h3>	<a name="S4.4">
Image Filenames and Options
</h3>	</a>
Images are specified, either by the <tt>RIMG</tt>, <tt>TIMG</tt>, or <tt>TALP</tt>
sub-chunks, as a filename
string.  If this is a simple filename, then it represents a still image.  However,
if the last part of the string is <tt>" (sequence)"</tt>, then the first
part of the string specifies the prefix of an image sequence and the
actual filename is generated by appending the three digit frame number to 
the prefix when loading the image file for each frame.  If the last part of
the string is <tt>" (clip)"</tt>, then the string is the name of
a Flyer clip.
<p>
The following sub-chunks may be used to set options for images.  Each of these
sub-chunks refers to image immediately preceeding it in the <tt>SURF</tt> data.
<p>

<dl><dl>
<dt><i>		<a name="s_IMSQ">
    Sequence Options
</i><p><dd><tt><b> </a>
	IMSQ { offset<a href="#t_I">[U2]</a>, flags<a href="#t_I">[U2]</a>, loop-length<a href="#t_I">[U2]</a> }
</tt></b><p>
	This only applies if the image is a sequence.
	The offset is added to the frame number to get the image number
	for that frame.  The loop-length is the number of frames before the
	sequence starts at the beginning again.  The least significant flag
	bit indicates that the sequence does loop, and the next bit indicates
	that the images are interlaced and should be treated as fields.
<p>

<dt><i>		<a name="s_FLYR">
    Flyer Clip Options
</i><p><dd><tt><b> </a>
	FLYR { begin<a href="#t_I">[U4]</a>, end<a href="#t_I">[U4]</a> }
</tt></b><p>
	This only applies if the image is a Flyer clip.  The two values are the clip
	endpoints stored in Flyer timecode format.
<p>

<dt><i>		<a name="s_IMCC">
    Color Cycle Options
</i><p><dd><tt><b> </a>
	IMCC { cycle-speed<a href="#t_I">[U2]</a>, low-index<a href="#t_I">[U2]</a>, high-index<a href="#t_I">[U2]</a> }
</tt></b><p>
	Only color-mapped images can use color cycling.  The cycle-speed can be +1,
	-1 or 0, but 0 means the sub-chunk can be ignored.  The low-index and
	high-index give the color table range to cycle through while rendering.
<p>
</dl></dl>


<!------------------------------>
<h2><hr> <a name="S5">
Object File Example
</h2> </a>

  A simple object (with somewhat complex surfaces) is listed below to
  illustrate some of the features of a FORM LWOB.  The object is an
  image-mapped square polygon and a transparent, reflective, bumpy
  yellow triangle.  They are made from 5 points in the XY plane.  The
annotations are laid out like a disassembly, with left collumn showing
the binary file data listed as two hexadecimal digits per byte, the center
collumn showing a symbolic breakdown of the file, and the far right
showing commentary on each line.
<p>

<dl><dd>
The file starts with the standard simple form IFF header.  It is just a
chunk of type
<a href="#t_FORM"><tt>FORM</tt></a>
which identifies this file as an IFF.  The first four bytes in the main
outer chunk are the ID <tt>LWOB</tt> which specifies this is a LightWave
Object File IFF.

<p></dl><pre>
464f524d 000001fe            FORM {		   IFF file header; FORM chunk
						   file length is 510 + 8 bytes
4c574f42                       LWOB		   FORM type ID for LW OBjects
</pre><dl><dd>

The first data chunk in this file is the
<a href="#c_PNTS"><tt>PNTS</tt></a>
chunk.  The chunk length is 60, so we know there are 5 points.  We just
read X, Y, and Z triples until we are get them all.  The points are numbered
starting from zero for indexing later.

<p></dl><pre>
504e5453 0000003c              PNTS {		   60 bytes / 12 = 5 points
00000000 3f800000 00000000       0.0,  1.0, 0.0	   point 0
40200000 3f800000 00000000       2.5,  1.0, 0.0	   point 1
40200000 bf800000 00000000       2.5, -1.0, 0.0	   point 2
00000000 bf800000 00000000       0.0, -1.0, 0.0	   point 3
c0000000 00000000 00000000      -2.0,  0.0, 0.0	   point 4
                               }
</pre><dl><dd>

Next is the
<a href="#c_SRFS"><tt>SRFS</tt></a>
chunk which lists the surfaces used by the polygons.  The surface names are
numbered from 1.  Note the double-nulls to make string lengths even.

<p></dl><pre>
53524653 00000012              SRFS {
54 72 69 61 6e 67 6c 65 00 00    "Triangle"	   surface 1
53 71 75 61 72 65 00 00          "Square"	   surface 2
                               }
</pre><dl><dd>

Now that we have points and surfaces indexed, we can read the
<a href="#c_POLS"><tt>POLS</tt></a>
chunk.  Polygon descriptions are variable-length, but we keep reading until
we have consumed the 22 bytes listed in the chunk header.  Note that vertex
indices are 0 to 4, but surface indices are 1 to 2.  A negative surface index
would flag detail polygons.

<p></dl><pre>
504f4c53 00000016              POLS {
  0003                           3		   polygon 1 has 3 vertices
     0003 0004 0000              3, 4, 0	   polygon 1 vertex list
     0001                        1                 polygon 1 uses "Triangle" surface

  0004                           4		   polygon 2 has 4 vertices
     0000 0001 0002 0003         0, 1, 2, 3	   polygon 2 vertex list
     0002                        2		   polygon 2 uses "Square" surface
                               }
</pre><dl><dd>

The complete geometry has been read, so the rest of the file is dedicated
to surface definitions.  The following 
<a href="#c_SURF"><tt>SURF</tt></a>
chunk describes the "Triangle" surface.  It is a double-sided, glossy, transparent
yellow surface with a fractal bump map.  The chunk contains
<a href="#t_SUBCH">sub-chunks</a> which have a two-byte length instead of
the four bytes used by the main data chunks.
Note that there is a fixed-point
and floating-point value for each shading parameter,
like <tt>DIFF</tt> and <tt>VDIF</tt>.  The fixed-point form is included by
LightWave when writing objects in order to assure backward compatibility.  
When writing objects for 4.0 LightWave or higher, only the floating-point
forms need to be used.

<p></dl><pre>
53555246 000000c8              SURF {	 	   start defintion of "Triangle"
54 72 69 61 6e 67 6c 65 00 00    "Triangle"	   surface settings

    434f4c52 0004                COLR {		   base color is yellow
    f0 b4 00 00                    240, 180, 0
                                 }
    464c4147 0002                FLAG {		   surface is double-sided
    0100                           [00100000000]
                                 }
    44494646 0002                DIFF {		   fixed 60% diffuse
    009a                           154
                                 }
    56444946 0004                VDIF {		   float 60% diffuse
    3f19999a                       0.6
                                 }
    53504543 0002                SPEC {            fixed 80% specular
    00cd                           205
                                 }
    56535043 0004                VSPC {		   float 80% specular
    3f4ccccd                       0.8
                                 }
    474c4f53 0002                GLOS {		   "High" glossiness
    0100                           256
                                 }
    5245464c 0002                REFL {		   fixed 20% reflective
    0033                           51
                                 }
    5652464c 0004                VRFL {		   float 20% reflective
    3e4ccccd                       0.2
                                 }
    52464c54 0002                RFLT {		   reflect backdrop colors and
    0001                           1		   raytraced objects
                                 }
    5452414e 0002                TRAN {		   fixed 40% transparent
    0066                           102
                                 }
    5654524e 0004                VTRN {		   float 40% transparent
    3ecccccd                       0.4
                                 }
    52494e44 0004                RIND {		   refractive index
    3f800000                       1.2		   1.2
                                 }

    42544558 000e                BTEX {		   start bump map
    46 72 61 63 74 61 6c 20			   using "Fractal Bumps" algorithm
    42 75 6d 70 73 00              "Fractal Bumps"
                                 }
    54464c47 0002                TFLG {		   Y-axis; world-coords;
    006a                           [1101010]	   pixel blending; antialiasing
                                 }
    5453495a 000c                TSIZ {		   texture size
    3dcccccd 3dcccccd 3dcccccd     0.1, 0.1, 0.1
                                 }
    54414153 0004                TAAS {		   texture antializing strength
    3f800000                       1.0		   100%
                                 }
    54414d50 0004                TAMP {		   bump amplitude
    3f000000                       1.5		   150%
                                 }
    54495030 0002                TIP0 {		   first integer parameter
    0003                           3		   3 fractal noise frequences
                                 }
                               }		   end of SURF chunk
</pre><dl><dd>

Last is the <a href="#c_SURF"><tt>SURF</tt></a>
chunk for the "Square" surface.  It is a single-sided surface with a
color map from an image.  Even though both surfaces have only one texture 
each, they could either of them have no textures, or an unlimited number.
They would be applied in the order they were read from the surface definition.

<p></dl><pre>
53555246 000000a6              SURF {		   start definition of "Square"
53 71 75 61 72 65 00 00          "Square"	   surface settings

    434f4c52 0004                COLR {		   base color is white
    c8 c8 c8 00                    200, 200, 200
                                 }
    464c4147 0002                FLAG {		   all surface flags clear
    0000                           [000000000]
                                 }
    44494646 0002                DIFF {		   fixed 100% diffuse
    0100                           256
                                 }
    56444946 0004                VDIF {		   float 100% diffuse
    3f800000                       1.0
                                 }

    43544558 0012                CTEX {		   start color map using
    50 6c 61 6e 61 72 20 49 6d			   "Planar Image Map" algorithm
    61 67 65 20 4d 61 70 00 00     "Planar Image Map"
                                 }
    54494d47 0012                TIMG {		   static image used for mapping
    49 6d 61 67 65 73 5c 6d 69	
    72 61 67 65 2e 69 66 66 00     "Images\mirage.iff"
                                 }
    54575250 0004                TWRP {		   image will tile in both directions
    0002 0002                      2, 2
                                 }
    54464c47 0002                TFLG {		   Z-axis; pixel blending;
    0064                           [1100100]	   antialiasing
                                 }
    5453495a 000c                TSIZ {		   image size (only X and Y matter)
    40200000 40000000 3f800000     2.5, 2.0, 1.0
                                 }
    54435452 000c                TCTR {		   image center (only X and Y matter)
    3fa00000 00000000 00000000     1.25, 0.0, 0.0
                                 }
    54414153 0004                TAAS {		   texture antialiasing strength
    3f800000                       1.0		   100%
                                 }
    54434c52 0004                TCLR {		   texture color is black (unused)
    00 00 00 00                    0, 0, 0
                                 }
                               }		   end of SURF chunk
                             }			   end of FORM chunk and file
</pre>

<!------------------------------>
<h3><hr> <a name="S6">
Index
</h3> </a>

<ul>

<li><a href="#s_ALPH">	ALPH</a>
<li><a href="#s_ALPH">	Alpha Mode</a>
<li><a href="#s_COLR">	Base Color</a>
<li><a href="#s_Vxxx">	Base Shading Values</a>
<li><a href="#s_xTEX">	BTEX</a>
<li><a href="#t_CHUNK">	Chunk</a>
<li><a href="#t_COL4">	COL4</a>
<li><a href="#s_COLR">	COLR</a>
<li><a href="#s_IMCC">	Color Cycling</a>
<li><a href="#s_xTEX">	CTEX</a>
<li><a href="#c_CRVS">	Curve List</a>
<li><a href="#t_DEG4">	DEG4</a>
<li><a href="#s_Vxxx">	DIFF</a>
<li><a href="#s_xTEX">	DTEX</a>
<li><a href="#s_EDGE">	EDGE</a>
<li><a href="#s_EDGE">	Edge Tranparency Threshold</a>
<li><a href="#t_F4">	F4</a>
<li><a href="#c_POLS">	Face List</a>
<li><a href="#s_FLAG">	FLAG</a>
<li><a href="#s_FLYR">	FLYR</a>
<li><a href="#s_FLYR">	Flyer Clip Options</a>
<li><a href="#t_FNAM0">	FNAM0</a>
<li><a href="#t_FORM">	FORM</a>
<li><a href="#t_FORM">	Format Header</a>
<li><a href="#t_FP4">	FP4</a>
<li><a href="#s_GLOS">	GLOS</a>
<li><a href="#t_I">	I1</a>
<li><a href="#t_I">	I2</a>
<li><a href="#t_I">	I4</a>
<li><a href="#t_ID4">	ID4</a>
<li><a href="#s_IMCC">	IMCC</a>
<li><a href="#s_IMSQ">	IMSQ</a>
<li><a href="#t_IP2">	IP2</a>
<li><a href="#s_Vxxx">	LUMI</a>
<li><a href="#s_xTEX">	LTEX</a>
<li><a href="#t_FORM">	LWOB</a>
<li><a href="#s_SMAN">	Max Smoothing Angle</a>
<li><a href="#t_SUBCH">	Mini-chunk</a>
<li><a href="#c_PCHS">	Patch List</a>
<li><a href="#s_SHDR">	Plug-in Shader</a>
<li><a href="#s_SDAT">	Plug-in Shader Data</a>
<li><a href="#c_PNTS">	Point List</a>
<li><a href="#s_Vxxx">	REFL</a>
<li><a href="#s_RIMG">	Reflection Map Image</a>
<li><a href="#s_RSAN">	Reflection Map Seam Angle</a>
<li><a href="#s_RFLT">	Reflection Mode</a>
<li><a href="#s_RIND">	Refractive Index</a>
<li><a href="#s_RFLT">	RFLT</a>
<li><a href="#s_RIMG">	RIMG</a>
<li><a href="#s_RIND">	RIND</a>
<li><a href="#s_RSAN">	RSAN</a>
<li><a href="#s_xTEX">	RTEX</a>
<li><a href="#t_S0">	S0</a>
<li><a href="#s_SDAT">	SDAT</a>
<li><a href="#s_IMSQ">	Sequence Options</a>
<li><a href="#s_SHDR">	SHDR</a>
<li><a href="#s_SMAN">	SMAN</a>
<li><a href="#s_SMAN">	Smoothing Angle</a>
<li><a href="#s_GLOS">	Specular Glossiness</a>
<li><a href="#s_Vxxx">	SPEC</a>
<li><a href="#s_xTEX">	STEX</a>
<li><a href="#t_SUBCH">	Sub-chunk</a>
<li><a href="#c_SURF">	Surface Definition</a>
<li><a href="#s_FLAG">	Surface Flags</a>
<li><a href="#c_SRFS">	Surface List</a>
<li><a href="#s_TAAS">	TAAS</a>
<li><a href="#s_TALP">	TALP</a>
<li><a href="#s_TAMP">	TAMP</a>
<li><a href="#s_TCLR">	TCLR</a>
<li><a href="#s_TSIZ">	TCTR</a>
<li>			Texture
	<ul>
	<li><a href="#s_TxPn">	Algorithmic Parameters</a>
	<li><a href="#s_TAAS">	Antialiasing Strength</a>
	<li><a href="#s_TAMP">	Bump Amplitude</a>
	<li><a href="#s_TCLR">	Color</a>
	<li><a href="#s_TFLG">	Flags</a>
	<li><a href="#s_TALP">	Image Alpha</a>
	<li><a href="#s_TIMG">	Image Map</a>
	<li><a href="#s_TWRP">	Image Wrap Modes</a>
	<li><a href="#s_TSIZ">	Location and Size</a>
	<li><a href="#s_TxPn">	Noise Frequencies</a>
	<li><a href="#s_TOPC">	Opacity</a>
	<li><a href="#s_TREF">	Reference Object</a>
	<li><a href="#s_xTEX">	Start Definition</a>
	<li><a href="#s_TVAL">	Value</a>
	<li><a href="#s_TxPn">	Wave Sources</a>
	</ul>
<li><a href="#s_TSIZ">	TFAL</a>
<li><a href="#s_TFLG">	TFLG</a>
<li><a href="#s_TxPn">	TFPn</a>
<li><a href="#s_TxPn">	TFRQ</a>
<li><a href="#s_TIMG">	TIMG</a>
<li><a href="#s_TxPn">	TIPn</a>
<li><a href="#s_TOPC">	TOPC</a>
<li><a href="#s_Vxxx">	TRAN</a>
<li><a href="#s_TREF">	TREF</a>
<li><a href="#s_TSIZ">	TSIZ</a>
<li><a href="#s_TxPn">	TSPn</a>
<li><a href="#s_xTEX">	TTEX</a>
<li><a href="#s_TVAL">	TVAL</a>
<li><a href="#s_TSIZ">	TVEL</a>
<li><a href="#s_TWRP">	TWRP</a>
<li>			Type
	<ul>
	<li><a href="#t_DEG4">	Angle</a>
	<li><a href="#t_COL4">	Color</a>
	<li><a href="#t_VEC12">	Coordinate</a>
	<li><a href="#t_FNAM0">	Filename</a>
	<li><a href="#t_F4">	Float</a>
	<li><a href="#t_ID4">	ID Tag</a>
	<li><a href="#t_I">	Integer, Signed</a>
	<li><a href="#t_I">	Integer, Unsigned</a>
	<li><a href="#t_IP2">	Percentage, Integer</a>
	<li><a href="#t_FP4">	Percentage, Floating-point</a>
	<li><a href="#t_S0">	String</a>
	</ul>
<li><a href="#t_I">	U1</a>
<li><a href="#t_I">	U2</a>
<li><a href="#t_I">	U4</a>
<li><a href="#s_Vxxx">	VDIF</a>
<li><a href="#t_VEC12">	VEC12</a>
<li><a href="#s_Vxxx">	VLUM</a>
<li><a href="#s_Vxxx">	VRFL</a>
<li><a href="#s_Vxxx">	VSPC</a>
<li><a href="#s_Vxxx">	VTRN</a>
</ul>

</body></html>

